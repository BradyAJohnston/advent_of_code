[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code",
    "section": "",
    "text": "Just a quick website to post my advent of code workins for 2022."
  },
  {
    "objectID": "2022-python.html",
    "href": "2022-python.html",
    "title": "Python",
    "section": "",
    "text": "Trying to practice with using OOP and classes inside of python.\nThe idea that I am going to be aiming for, is to have a class to represent an elf, and then also a class that contains all of the elves together.\nUnsure really about how classes work, so this will be an experiment!"
  },
  {
    "objectID": "2022-python.html#day-1",
    "href": "2022-python.html#day-1",
    "title": "Python",
    "section": "Day 1",
    "text": "Day 1\n\nPart 1\n\nRead in the data in python.\nLets first get all of the data inside and have a look at it.\n\nfile = \"data/day1.txt\"\nf = open(file)\nlines = f.read()\nf.close()\n\nlines = lines.split('\\n')\nlines[:10]\n\n['5474', '4920', '5381', '8650', '11617', '7193', '8161', '', '10747', '5855']\n\n\n\n\n\nA class for Elves.\nI’ll want a class that is an elf, which at least to begin with will have an id number to identify which elf it is, but also a place to store which snacks they are carrying, and a function to count up the calories of all of the snacks they are carrying.\n\nclass Elf:\n  def __init__(self, id = int(1)):\n    self.snacks = []\n    self.id = int(id)\n\n  def add_snack(self, calories):\n    self.snacks.append(calories)\n    \n  def cal_total(self):\n    if len(self.snacks) == 0:\n      return 0\n    return sum(self.snacks)\n\nNow we want a class than can hold multiple elves, with a function to add an elf, and a function to find which elf has the most calories.\n\nclass Mischief:\n  def __init__(self):\n    self.elves = []\n  \n  def add_elf(self):\n    self.elves.append(Elf(len(self.elves)))\n  \n  def add_elves_and_snacks(self, lines):\n    new_elf = True  \n    counter = 0\n    for snack in lines:\n      if new_elf:\n        self.add_elf()\n        new_elf = False\n      if snack != \"\":\n        group.elves[counter].add_snack(int(snack))\n      else:\n        new_elf = True\n        counter += 1\n  \n  def get_elf_max_cal(self):\n    max_elf = self.elves[0]\n    for elf in self.elves:\n      if elf.cal_total() > max_elf.cal_total():\n        max_elf = elf\n    \n    print(f\"Elf No. {max_elf.id} with {max_elf.cal_total()} calories.\")\n    return max_elf\n\n\n# setup the mischief of elves\ngroup = Mischief()\n\n# add the elves and their snacks\n# I feel like this should be part of the setup, but I can't currenlty figure out\n# how to get it working\ngroup.add_elves_and_snacks(lines)\n\n# find the elf with the most snacks!\ngroup.get_elf_max_cal()\n\nElf No. 30 with 66306 calories.\n\n\n<__main__.Elf at 0x7fd131ffc580>\n\n\n\n\nPart 2\nFind the top 3 elves, and how many calories total they all are carrying.\n\nall_snack_totals = [elf.cal_total() for elf in group.elves]\nall_snack_totals.sort(reverse=True)\ntop_3 = sum(all_snack_totals[:3])\nprint(f\"The 3 elves with the most snacks have a combined {top_3} calories.\")\n\nThe 3 elves with the most snacks have a combined 195292 calories.\n\n\nWhile this finds the top 3 elf snack calories and adds them together, it’s unclear where those totals are coming from. Thant’s something I’d like to improve, but this is where I will leave this part for the python component."
  },
  {
    "objectID": "2022-r-lang.html",
    "href": "2022-r-lang.html",
    "title": "R-lang",
    "section": "",
    "text": "Document for workingo out solutions to the advent of code.\nThe approach that I am going to be taking for the R code is a very {tiydyverse}-centric, trying to leverage nested dadtaframes and mapping as much as possible."
  },
  {
    "objectID": "2022-r-lang.html#day-1",
    "href": "2022-r-lang.html#day-1",
    "title": "R-lang",
    "section": "Day 1",
    "text": "Day 1\nPart 1\nRead in the data:\n\n\n\nCode\n\noptions(tidyverse.quiet = TRUE)\nlibrary(tidyverse)\n\ndat <- read_lines('data/day1.txt') |> \n  as_tibble() |> \n  rename(calories = 1)\n\nhead(dat)\n\n\n# A tibble: 6 × 1\n  calories\n  <chr>   \n1 5474    \n2 4920    \n3 5381    \n4 8650    \n5 11617   \n6 7193    \n\n\nEach data point is separated by an empty line, we can check when those lines are empty and count upwards, to label each datapoints for each elf.\n\n\n\nCode\n\ndat <- dat |> \n  mutate(\n    calories = as.numeric(calories), \n    elf = cumsum(is.na(calories)) + 1\n  )\ndat\n\n\n# A tibble: 2,244 × 2\n   calories   elf\n      <dbl> <dbl>\n 1     5474     1\n 2     4920     1\n 3     5381     1\n 4     8650     1\n 5    11617     1\n 6     7193     1\n 7     8161     1\n 8       NA     2\n 9    10747     2\n10     5855     2\n# … with 2,234 more rows\n\n\nNow we can remove the empty rows, and nest the data for each elf.\n\n\n\nCode\n\ndat <- dat |> \ndrop_na(calories) |> \n  group_by(elf) |> \n  nest() \ndat\n\n\n# A tibble: 242 × 2\n# Groups:   elf [242]\n     elf data             \n   <dbl> <list>           \n 1     1 <tibble [7 × 1]> \n 2     2 <tibble [6 × 1]> \n 3     3 <tibble [13 × 1]>\n 4     4 <tibble [10 × 1]>\n 5     5 <tibble [14 × 1]>\n 6     6 <tibble [1 × 1]> \n 7     7 <tibble [2 × 1]> \n 8     8 <tibble [5 × 1]> \n 9     9 <tibble [7 × 1]> \n10    10 <tibble [8 × 1]> \n# … with 232 more rows\n\n\nFor each nested dataframe, we can sum together the calories and arrange the dataframe based on the descending total of calories\n\n\n\nCode\n\ndat <- dat |> \n  mutate(\n    total = map_dbl(data, sum)\n  ) |> \n  arrange(-total)\n\ndat\n\n\n# A tibble: 242 × 3\n# Groups:   elf [242]\n     elf data              total\n   <dbl> <list>            <dbl>\n 1    31 <tibble [12 × 1]> 66306\n 2   160 <tibble [14 × 1]> 64532\n 3   161 <tibble [1 × 1]>  64454\n 4    53 <tibble [14 × 1]> 64230\n 5     9 <tibble [7 × 1]>  63623\n 6   133 <tibble [14 × 1]> 63339\n 7   202 <tibble [11 × 1]> 62944\n 8   177 <tibble [6 × 1]>  62852\n 9   109 <tibble [3 × 1]>  62425\n10   181 <tibble [3 × 1]>  62355\n# … with 232 more rows\n\n\nPart 2\nWe need to first ungroup the rows, then rank the totals and get only the top 3 values.\n\n\n\nCode\n\ndat |> \n  ungroup() |> \n  filter(\n    rev(rank(total)) %in% 1:3\n  ) |> \n  summarise(total = sum(total))\n\n\n# A tibble: 1 × 1\n   total\n   <dbl>\n1 195292\n\n\nAdditional Poking Around\nSome additional visulisations of the daily data.\n\ndat |> \n  ggplot(aes(total)) + \n  geom_histogram(\n    fill = \"gray50\", \n    binwidth = 2000\n  ) + \n  labs(\n    x = \"Calories Carried\", \n    y = \"Number of Elves\"\n  ) + \n  theme_bw()"
  }
]